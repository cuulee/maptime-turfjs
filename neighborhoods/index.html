<!DOCTYPE html>
<html>
<head>
<meta charset=utf-8 />
<title>turfjs neighborhood mapping</title>
<meta name='viewport' content='initial-scale=1,maximum-scale=1,user-scalable=no' />
<link rel='stylesheet' href="https://npmcdn.com/leaflet@1.0.0-rc.2/dist/leaflet.css" />
<link rel='stylesheet' href='https://api.mapbox.com/mapbox.js/plugins/leaflet-draw/v0.2.3/leaflet.draw.css' />
</head>
<body>

<script src="https://npmcdn.com/leaflet@1.0.0-rc.2/dist/leaflet.js"></script>
<script src='https://api.mapbox.com/mapbox.js/plugins/leaflet-draw/v0.2.3/leaflet.draw.js'></script>
<script src='https://api.tiles.mapbox.com/mapbox.js/plugins/turf/v3.0.11/turf.min.js'></script>
<script src="https://d3js.org/d3.v4.min.js"></script>

<style>
  body {
    color: #333;
    font-family: "Courier New", Courier, monospace;
    margin:0;
    padding:0;
  }

  #map { 
    position:absolute; 
    top:0; 
    bottom:0; 
    width:100%; 
  }
  #footer {
	  position: absolute;
	  bottom: 0;
	  left: 0;
	  right: 0;
	  background: #121212;
	  z-index: 999;
	  overflow: auto;
	  padding: 5px;
	  opacity: 0.95;
	  color: #999;
    border-top: 1px solid #999;
	}
  
</style>

<div id='map'></div>

<div id="footer">
  <div class="container" style="padding-left:20px;">
    <h2>Draw the Back Bay!</h2>
    <h4>This is an example of <a href="http://bostonography.com/2015/map-your-neighborhood-again/" target="_blank">neighborhood mapping</a> using in-browser geoprocessing via <a href="http://turfjs.org/" target="_blank">turf.js</a> to determine the agreement of multiple drawings</h4>
  </div>
  </div>

<script>
  // CONFIGURE THE MAP
  var map = L.map('map')
    .setView([42.35070, -71.08102], 15);

  L.tileLayer('http://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}.png',{ 
    attribution: '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors, &copy; <a href="https://cartodb.com/attributions">CartoDB</a>' 
  }).addTo(map);

  // CONFIGURE THE DRAWING BEHAVIOR AND LAYERS
  var featureGroup = L.featureGroup().addTo(map);
  var pointLayer;

  var drawControl = new L.Control.Draw({
    position: 'topright',
    edit: {
      featureGroup: featureGroup
    },
    draw: {
      polyline: false,
      marker: false,
      circle: false,
      rectangle: false
    }
  }).addTo(map);

  drawControl.setDrawingOptions({
    polygon: {
      shapeOptions: {
        weight: 0.2,
        opacity: 0.7,
        color: '#e2e3e3',
        fillOpacity: 0
      }
    }
  });

  map.on('draw:created', function(e) {
    // ADD THE DRAWN LAYER TO THE COLLECTION
    featureGroup.addLayer(e.layer);
    // TURN IT INTO GEOJSON TO USE W/ TURF
    var data = featureGroup.toGeoJSON();
    // CALCULATE THE BOUNDING BOX TO GENERATE THE GRID
    var bbox = turf.bbox(data);
    // GENERATE THE GRID
    var pointGrid = turf.pointGrid(bbox, 50, 'meters');
    // PREPARE THE DRAWINGS FOR TOPOLOGY TESTS
    var featureUnion = turf.combine(data);
    // CREATE A SHELL GEOJSON FOR THE PROCESSED POINT GRID
    var finalGrid = {"type": "FeatureCollection","features": []};
    // ADD POINTS TO THE GRID ONLY IF THEY OVERLAP A DRAWING
    for (var i = 0; i < pointGrid.features.length; i++) {
      if (turf.inside(pointGrid.features[i], featureUnion.features[0]) == true ) {
        var pointHere = pointGrid.features[i];
        // ITERATE THROUGH THE DRAWINGS, SUMMING UP THE AGREEMENT
        pointHere.properties.drawings = 0;
        for (var d = 0; d < data.features.length; d++) {
          if (turf.inside(pointHere, data.features[d]) == true ) {
            pointHere.properties.drawings++
          }
        }
        finalGrid.features.push(pointHere);
      }
    }
    // SCALE THE POINTS IN THE GRID ACCORDING TO PERCENT AGREEMENT
    let countMin = d3.min(finalGrid.features, function(d) { return d.properties.drawings; });
    let countMax = d3.max(finalGrid.features, function(d) { return d.properties.drawings; });
    // SET A RADIUS BETWEEN 2 AND 10
    let radiusScale = d3.scaleLog()
      .domain([countMin,countMax])
      .range([2,12])
      
    let percentScale = d3.scaleLinear()
      .domain([countMin,countMax])
      .range([0,1])
    
    // ADD THE POINT GRID TO THE MAP (OR REFRESH IT)
    if (map.hasLayer(pointLayer)) {
      map.removeLayer(pointLayer);
    }
    
    function onEachFeature(feature, layer) {
      if (feature.properties && feature.properties.drawings) {
        layer.bindPopup((Math.floor(percentScale(feature.properties.drawings) * 100)) + '% agreement');
      }
    }
    pointLayer = L.geoJson(finalGrid, {

			style: function (feature) {
				return feature.properties && feature.properties.style;
			},
      onEachFeature: onEachFeature,
			pointToLayer: function (feature, latlng) {
        // STYLE THE GRID USING THE AGREEMENT METRICS
				return L.circleMarker(latlng, {
					radius: radiusScale(feature.properties.drawings),
					fillColor: "#E9D03D",
					color: "#E9D03D",
					weight: 0.2,
					opacity: 0.9,
					fillOpacity: percentScale(feature.properties.drawings) - 0.1
				});
			}
		}).addTo(map);

  });
</script>
</body>
</html>
